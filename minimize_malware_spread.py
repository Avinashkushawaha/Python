class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.sz = [1]*n
    def find(self, x):
        while x != self.p[x]:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return
        if self.sz[ra] < self.sz[rb]: ra, rb = rb, ra
        self.p[rb] = ra
        self.sz[ra] += self.sz[rb]

def minimizeMalwareSpread(graph, initial):
    n = len(graph)
    dsu = DSU(n)
    for i in range(n):
        for j in range(i+1, n):
            if graph[i][j]: dsu.union(i, j)
    comp_size = collections.Counter(dsu.find(i) for i in range(n))
    infected_in_comp = collections.Counter(dsu.find(i) for i in initial)
    # choose node that uniquely infects largest component; tie -> smallest index
    best = min(initial)
    best_saved = -1
    for node in sorted(initial):
        root = dsu.find(node)
        if infected_in_comp[root] == 1:
            saved = comp_size[root]
            if saved > best_saved:
                best_saved = saved
                best = node
    return best

# import collections
# print(minimizeMalwareSpread([[1,1,0],[1,1,0],[0,0,1]],[0,1]))
